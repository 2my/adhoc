import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.contains;import static org.hamcrest.Matchers.containsInAnyOrder;import static org.hamcrest.Matchers.equalTo;import static org.mockito.Mockito.times;import java.util.Arrays;import java.util.List;import org.codehaus.jackson.JsonGenerator;import org.codehaus.jackson.JsonProcessingException;import org.codehaus.jackson.Version;import org.codehaus.jackson.map.JsonSerializer;import org.codehaus.jackson.map.ObjectMapper;import org.codehaus.jackson.map.SerializerProvider;import org.codehaus.jackson.map.module.SimpleModule;import org.hamcrest.Description;import org.hamcrest.Factory;import org.hamcrest.Matcher;import org.hamcrest.TypeSafeMatcher;import org.junit.After;import org.junit.Before;import org.junit.BeforeClass;import org.junit.Test;import org.mockito.ArgumentCaptor;import org.mockito.InOrder;import org.mockito.Mockito;import org.mockito.invocation.InvocationOnMock;import org.mockito.stubbing.Answer;class GoldenTest{	class ToMock {		public String read( String param ) {			return param;		}	}	@BeforeClass public static void setUpBeforeClass() throws Exception {	}	@Before public void setUp() throws Exception {	}	@After public void tearDown() {	}	@Test public void whatever() throws Exception {		ToMock mocked	= Mockito.mock( ToMock.class );		// failure first, then success		Mockito.when( mocked.read( "" ) )			.thenThrow(new RuntimeException())			.thenReturn("foo")		;		InOrder inOrder = Mockito.inOrder( mocked );		inOrder.verify( mocked, times(1) ).read( "some" );		inOrder.verify( mocked, times(1) ).read( "other" );		/* List: http://www.baeldung.com/hamcrest-collections-arrays		contains : same order, same size		containsInAnyOrder : same order		hasItems : any order, different size		*/		List<String> collection = Arrays.asList("ab", "cd", "ef");		assertThat(collection, contains("ab", "cd", "ef"));		assertThat(collection, containsInAnyOrder("cd", "ab", "ef"));		// Logging Answer or Modding input -----------------------------------------------		Mockito.doAnswer( new LogCall() ).when( mocked ).read( Mockito.anyString() );		// Mockito.any( Date.class )		// ArgumentCaptor ------------------------------------------------------------		ArgumentCaptor<String> strArg = ArgumentCaptor.forClass( String.class );		Mockito.verify( mocked ).read( strArg.capture() );		assertThat( strArg.getValue(), equalTo( "whatever" ) );	}	private class LogCall implements Answer<Object> {		// @Override		public Object answer(InvocationOnMock invocation) {			Object[] args = invocation.getArguments();			StringBuffer sb	= new StringBuffer();			sb.append( "read( " 					+ (String) args[0] + ", " 					// + (Double) args[1] + ", "					// + ((java.util.Date) args[2]).getTime()				+ ")"			);			return null;		}	};	// TypeSafeMatcher ------------------------------------------------------------	@Factory static <T> Matcher<String> match( final String expectedValue ) {		return new TypeSafeMatcher<String>() {			@Override public boolean matchesSafely( String actual ) {				return expectedValue.equals( actual );			}			public void describeTo(Description description) {				description.appendValueList( "String[", ", ", "]", expectedValue );			}		};	}	// JSON ------------------------------------------------------------	/** print large object as json */	static String dumpJson( Object o ) {		ObjectMapper mapper = new ObjectMapper();    SimpleModule testModule = new SimpleModule("MyModule", new Version(1, 0, 0, null));    testModule.addSerializer( ToMock.class,    		new JsonSerializer<ToMock>() {    			@Override public void serialize( ToMock value, JsonGenerator jgen, SerializerProvider provider ) throws java.io.IOException, JsonProcessingException {    				jgen.writeString( value.toString() );    			}				}  		);    mapper.registerModule(testModule);    try {    	return mapper.writerWithDefaultPrettyPrinter().writeValueAsString( o );		} catch ( Exception e ) {			throw new RuntimeException( "ERROR DUMPING " + o );		}	}}