// import static com.npspot.npsia.test.util.NpDateUtil.*;import static org.hamcrest.Matchers.*;import static org.hamcrest.MatcherAssert.*;import static org.mockito.Mockito.*;import org.hamcrest.*;import org.mockito.invocation.InvocationOnMock;import org.mockito.stubbing.Answer;import org.mockito.*;import org.codehaus.jackson.*;import org.codehaus.jackson.map.*;import org.codehaus.jackson.map.module.SimpleModule;import org.hamcrest.Matcher;import org.junit.*;class GoldenTest{	class ToMock {		public String read( String param ) {			return param;		}	}	@BeforeClass public static void setUpBeforeClass() throws Exception {	}	@Before public void setUp() throws Exception {	}  @After public void tearDown() {	}	@Test public void doTask_nois_component_flow() throws Exception {		ToMock mocked	= mock( ToMock.class );		// failure first, then success		when( mocked.read( "" ) )			.thenThrow(new RuntimeException())			.thenReturn("foo")		;		InOrder inOrder = inOrder( mocked );		inOrder.verify( mocked, times(1) ).read( "some" );		inOrder.verify( mocked, times(1) ).read( "other" );		/* List:		contains : same order, same size		containsInAnyOrder : same order		hasItems : any order, different size		*/		// Logging Answer or Modding input -----------------------------------------------		doAnswer( new LogCall() ).when( mocked ).read( anyString() );		// Mockito.any( Date.class )		// ArgumentCaptor ------------------------------------------------------------		ArgumentCaptor<String> strArg = ArgumentCaptor.forClass( String.class );		verify( mocked ).read( strArg.capture() );		assertThat( strArg.getValue(), equalTo( "whatever" ) );	}	private class LogCall implements Answer<Object> {		@Override public Object answer(InvocationOnMock invocation) {			Object[] args = invocation.getArguments();			StringBuffer sb	= new StringBuffer();			sb.append( "read( " 					+ (String) args[0] + ", " 					// + (Double) args[1] + ", "					// + ((java.util.Date) args[2]).getTime()				+ ")"			);			return null;		}	};	// TypeSafeMatcher ------------------------------------------------------------	@Factory static <T> Matcher<String> match( final String expectedValue ) {		return new TypeSafeMatcher<String>() {			@Override public boolean matchesSafely( String actual ) {				return expectedValue.equals( actual );			}			public void describeTo(Description description) {				description.appendValueList( "String[", ", ", "]", expectedValue );			}		};	}	// JSON ------------------------------------------------------------	/** print large object as json */	static String dumpJson( Object o ) {		ObjectMapper mapper = new ObjectMapper();    SimpleModule testModule = new SimpleModule("MyModule", new Version(1, 0, 0, null));    testModule.addSerializer( ToMock.class,    		new JsonSerializer<ToMock>() {    			@Override public void serialize( ToMock value, JsonGenerator jgen, SerializerProvider provider ) throws java.io.IOException, JsonProcessingException {    				jgen.writeString( value.toString() );    			}				}  		);    mapper.registerModule(testModule);    try {    	return mapper.writerWithDefaultPrettyPrinter().writeValueAsString( o );		} catch ( Exception e ) {			throw new RuntimeException( "ERROR DUMPING " + o );		}	}}